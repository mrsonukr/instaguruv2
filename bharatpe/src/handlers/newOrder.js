import { json } from '../utils';
import { processInstagramOrder } from './instagram';
import { notifyAdminsOnNewOrder } from '../tgbot/admin';

// Handler for POST /neworder
export async function handleNewOrder(request, env) {
	try {
		const body = await request.json();
		const { quantity, link, amount, service, txnId } = body;

		// Basic body validation (order_id is auto-generated by orders table)
		if (!quantity || !link || !amount || !service) {
			return json({ success: false, error: 'Missing required fields' }, 400);
		}

		const amountPaise = Math.round(amount * 100);

		// Check for duplicate txnId (only if txnId is provided)
		if (txnId) {
			const existingOrder = await env.bharatpe
				.prepare('SELECT order_id FROM orders WHERE txnId = ?1 LIMIT 1')
				.bind(txnId)
				.first();

			if (existingOrder) {
				return json({
					success: false,
					error: 'Duplicate transaction ID',
					code: 'DUPLICATE_TXNID',
					existing_order_id: existingOrder.order_id,
				}, 400);
			}
		}

		await env.bharatpe
			.prepare(
				`INSERT INTO orders 
			        (quantity, link, amount, service, apiid, created_at, txnId)
			         VALUES (?1, ?2, ?3, ?4, NULL, strftime('%s','now'), ?5)`
			)
			.bind(quantity, link, amountPaise, service, txnId)
			.run();

		// Fetch the newly created order with created_at
		const orderRow = await env.bharatpe
			.prepare(
				`SELECT order_id, created_at FROM orders 
			     WHERE rowid = last_insert_rowid()`
			)
			.first();

		const id = orderRow && orderRow.order_id ? orderRow.order_id : null;
		const createdAt = orderRow && orderRow.created_at ? orderRow.created_at : null;

		// Also trigger Instagram/Airgrow processing (non-blocking for DB insert)
		let smmJson;
		
		// Check if this is an Instagram order with service ID
		if (service && /^\d+$/.test(service)) {
			// This is an Instagram order with service ID, process directly
			const serviceId = parseInt(service);
			let selectedApi;
			
			// Determine API based on service ID
			if (serviceId === 6685) {
				selectedApi = 'tntsmm';
			} else if (serviceId === 13015 || serviceId === 12973) {
				// Instagram followers via SabkaSMM
				selectedApi = 'sakbasmm';
			} else if (serviceId === 565 || serviceId === 511 || serviceId === 589) {
				// SupportiveSMM services (likes/followers)
				selectedApi = 'supportivesmm';
			} else {
				selectedApi = 'airgrow';
			}
			
			// Make direct SMM API call
			let apiKey, baseUrl;
			if (selectedApi === 'tntsmm') {
				apiKey = env.TNTSMM_API_KEY;
				baseUrl = env.TNTSMM_API_URL;
			} else if (selectedApi === 'sakbasmm') {
				apiKey = env.SAKBASMM_API_KEY;
				baseUrl = env.SAKBASMM_API_URL;
			} else if (selectedApi === 'supportivesmm') {
				apiKey = env.SUPPORTIVESMM_API_KEY;
				baseUrl = env.SUPPORTIVESMM_API_URL;
			} else {
				apiKey = env.AIRGROWSMM_API_KEY;
				baseUrl = env.AIRGROWSMM_API_URL;
			}
			
			if (apiKey && baseUrl) {
				try {
					const apiUrl = `${baseUrl}?key=${apiKey}&action=add&service=${serviceId}&link=${encodeURIComponent(link)}&quantity=${quantity}`;
					const smmRes = await fetch(apiUrl);
					smmJson = await smmRes.json();
				} catch (err) {
					smmJson = { success: false, error: err.message };
				}
			}
		} else {
			// Original logic for other orders
			const smmRes = await processInstagramOrder(env, amount, link);
			try {
				smmJson = await smmRes.json();
			} catch {
				smmJson = null;
			}
		}

		// If SMM order returned an id, store it into apiid
		if (smmJson) {
			let smmOrderId = null;
			if (smmJson.orderId) {
				// Many panels return explicit orderId field
				smmOrderId = smmJson.orderId;
			} else if (
				smmJson.order !== undefined &&
				(
					typeof smmJson.order === 'number' ||
					(typeof smmJson.order === 'string' && /^\d+$/.test(smmJson.order))
				)
			) {
				// Some return numeric order directly in `order`
				smmOrderId = smmJson.order;
			}

			if (smmOrderId) {
				await env.bharatpe
					.prepare('UPDATE orders SET apiid = ? WHERE order_id = ?')
					.bind(smmOrderId, id)
					.run();
			}
		}

		try {
			let notifyApiId = null;
			if (smmJson) {
				if (smmJson.orderId) {
					notifyApiId = smmJson.orderId;
				} else if (
					smmJson.order !== undefined &&
					(
						typeof smmJson.order === 'number' ||
						(typeof smmJson.order === 'string' && /^\d+$/.test(smmJson.order))
					)
				) {
					notifyApiId = smmJson.order;
				} else if (smmJson.order === 'failed') {
					notifyApiId = 'failed';
				}
			}

			await notifyAdminsOnNewOrder(env, {
				id,
				quantity,
				link,
				amountRupees: amount,
				amountPaise,
				service,
				apiid: notifyApiId,
				created_at: createdAt,
				payername: null,
				payer: null,
				utr: null,
				txnId,
			});
		} catch (e) {
			console.log('[TG] notifyAdminsOnNewOrder failed:', e && e.message ? e.message : e);
		}

		return json({
			success: true,
			message: 'Order saved',
			order_id: id,
			amount_paise: amountPaise,
			smm: smmJson || null,
		});
	} catch (err) {
		const message = String(err && err.message ? err.message : '');

		// Handle duplicate order_id (UNIQUE constraint) gracefully
		if (message.includes('UNIQUE constraint failed: orders.order_id')) {
			return json(
				{
					success: false,
					error: 'Order with this ID already exists',
					code: 'ORDER_ID_EXISTS',
				},
				400
			);
		}

		// Handle duplicate txnId (UNIQUE constraint) gracefully
		if (message.includes('UNIQUE constraint failed: orders.txnId')) {
			return json(
				{
					success: false,
					error: 'Duplicate transaction ID',
					code: 'DUPLICATE_TXNID',
				},
				400
			);
		}

		// Generic fallback error (hide internal D1/SQL details)
		return json(
			{
				success: false,
				error: 'Something went wrong while creating the order',
			},
			500
		);
	}
}


