import { json } from '../utils';
import { processInstagramOrder } from './instagram';
import { notifyAdminsOnNewOrder } from '../tgbot/admin';

// Handler for POST /neworder
export async function handleNewOrder(request, env) {
	try {
		const body = await request.json();
		const { quantity, link, amount, service, txnId } = body;

		// Basic body validation (order_id is auto-generated by orders table)
		if (!quantity || !link || !amount || !service) {
			return json({ success: false, error: 'Missing required fields' }, 400);
		}

		const amountPaise = Math.round(amount * 100);

		// Check for duplicate txnId (only if txnId is provided)
		if (txnId) {
			const existingOrder = await env.bharatpe
				.prepare('SELECT order_id FROM orders WHERE txnId = ?1 LIMIT 1')
				.bind(txnId)
				.first();

			if (existingOrder) {
				return json({
					success: false,
					error: 'Duplicate transaction ID',
					code: 'DUPLICATE_TXNID',
					existing_order_id: existingOrder.order_id,
				}, 400);
			}
		}

		await env.bharatpe
			.prepare(
				`INSERT INTO orders 
			        (quantity, link, amount, service, apiid, created_at, txnId)
			         VALUES (?1, ?2, ?3, ?4, NULL, strftime('%s','now'), ?5)`
			)
			.bind(quantity, link, amountPaise, service, txnId)
			.run();

		// Fetch the newly created order with created_at
		const orderRow = await env.bharatpe
			.prepare(
				`SELECT order_id, created_at FROM orders 
			     WHERE rowid = last_insert_rowid()`
			)
			.first();

		const id = orderRow && orderRow.order_id ? orderRow.order_id : null;
		const createdAt = orderRow && orderRow.created_at ? orderRow.created_at : null;

		// Also trigger Instagram/Airgrow processing (non-blocking for DB insert)
		const smmRes = await processInstagramOrder(env, amount, link);
		let smmJson;
		try {
			smmJson = await smmRes.json();
		} catch {
			smmJson = null;
		}

		// If SMM order succeeded, store its order id into apiid
		if (smmJson && smmJson.success && smmJson.orderId) {
			await env.bharatpe
				.prepare('UPDATE orders SET apiid = ? WHERE order_id = ?')
				.bind(smmJson.orderId, id)
				.run();
		}

		try {
			await notifyAdminsOnNewOrder(env, {
				id,
				quantity,
				link,
				amountRupees: amount,
				amountPaise,
				service,
				apiid: smmJson && smmJson.success && smmJson.orderId ? smmJson.orderId : null,
				created_at: createdAt,
				payername: null,
				payer: null,
				utr: null,
				txnId,
			});
		} catch (e) {
			console.log('[TG] notifyAdminsOnNewOrder failed:', e && e.message ? e.message : e);
		}

		return json({
			success: true,
			message: 'Order saved',
			order_id: id,
			amount_paise: amountPaise,
			smm: smmJson || null,
		});
	} catch (err) {
		const message = String(err && err.message ? err.message : '');

		// Handle duplicate order_id (UNIQUE constraint) gracefully
		if (message.includes('UNIQUE constraint failed: orders.order_id')) {
			return json(
				{
					success: false,
					error: 'Order with this ID already exists',
					code: 'ORDER_ID_EXISTS',
				},
				400
			);
		}

		// Handle duplicate txnId (UNIQUE constraint) gracefully
		if (message.includes('UNIQUE constraint failed: orders.txnId')) {
			return json(
				{
					success: false,
					error: 'Duplicate transaction ID',
					code: 'DUPLICATE_TXNID',
				},
				400
			);
		}

		// Generic fallback error (hide internal D1/SQL details)
		return json(
			{
				success: false,
				error: 'Something went wrong while creating the order',
			},
			500
		);
	}
}


